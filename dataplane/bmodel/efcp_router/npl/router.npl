// This program implements the Error And Flow Control Protocol (EFCP), as well as legacy protocols

#include "bus.npl"
#include "parser.npl"
#include "special_function.npl"
#include "table.npl"
#include "debug.npl"
#include "constants.npl"

/*************************************
FUNCTION DECLARATION
*************************************/

// Resolve Destination
// - Pick destination results from one of the table lookups
function resolve_destination() {
    // By default on obj_bus dst_modid and dst_port are from the L2 table.
    // However if L3 lookup was successful then pick it from nhi table.
    ccbi.l2_pbm = 1 << obj_bus.dst_port;
}

// Assign data from the ingress bus (used in the ingress pipeline) to
// data in the egress bus (used in the egress pipeline)
// - Not needed by the logic (a single bus could be used for the whole program),
// - but nevertheless provided for architectural and educational reasons
function assign_ing_to_egr_bus() {
    egr_obj_bus.dst_modid       = obj_bus.dst_modid;
    egr_obj_bus.dst_port        = ccbe.dst_port;
    egr_obj_bus.ing_port        = obj_bus.port_num;
    egr_obj_bus.ingress_timestamp = time_bus.currenttime;
    egr_aux_bus.drop_vector     = 0;
}


/*************************************
PACKET MODIFICATION
*************************************/
// - To be implemented on Flex editor
function do_modify_packet () {
    egress_pkt.l2_hdr.l2 = ingress_pkt.l2_hdr.l2;
    egress_pkt.l2_hdr.vlan = ingress_pkt.l2_hdr.vlan;
    egress_pkt.efcp_hdr.efcp = ingress_pkt.efcp_hdr.efcp;
    egress_pkt.l3_hdr.ipv4 = ingress_pkt.l3_hdr.ipv4;
}

// Manage the VLAN header in the ingress packet
function handle_vlan() {     
    // Check if VLAN header is present in ingress packet regardless of whether
    // this is an EFCP or an IP packet
    if (ingress_pkt.l2_hdr.vlan._PRESENT) { 
        // Ingress packet has VLAN header, but egress packets must be without
        // This is specified in the table configuration.
        if (obj_bus.vlan_id == 0) {
            print("VLAN header present with vlan_id = 0\n");
            delete_header(ingress_pkt.l2_hdr.vlan);

            // Check whether it is an EFCP or IP packet in order to set the 
            // ethertype field in the Ethernet layer
            if (ingress_pkt.efcp_hdr.efcp._PRESENT) {
                obj_bus.eth_etype = EFCP_ETYPE;        
            } else if (ingress_pkt.l3_hdr.ipv4._PRESENT) {
                obj_bus.eth_etype = IPv4_ETYPE;        
            }             
            replace_header_field(ingress_pkt.l2_hdr.l2.ethertype, obj_bus.eth_etype);
        } else {
            // Ingress packet has a VLAN and egress packet must have as well
            // Thus, only the vlan_id field is changed
            print("VLAN header present, but vlan_id not 0. vlan_id = 0X%x\n", obj_bus.vlan_id);
            replace_header_field(ingress_pkt.l2_hdr.vlan.vlan_id, obj_bus.vlan_id);
        }
    } else {
        // VLAN header is not present in ingress packet
        // However, egress packet must have it. So VLAN header is added by the router
        if (obj_bus.vlan_id != 0) {
            print("Added VLAN header\n");        
            add_header(ingress_pkt.l2_hdr.vlan);
            replace_header_field(ingress_pkt.l2_hdr.vlan.vlan_id, obj_bus.vlan_id);

            // Replace ethertypes: Ethernet ethertype will be 0x8100 and VLAN
            // ethertype will be 0xD1F or 0x800
            obj_bus.eth_etype = VLAN_ETYPE;

            if (ingress_pkt.efcp_hdr.efcp._PRESENT) {
                obj_bus.vlan_etype = EFCP_ETYPE;        
            } else if(ingress_pkt.l3_hdr.ipv4._PRESENT) {
                obj_bus.vlan_etype = IPv4_ETYPE;        
            }                        
            replace_header_field(ingress_pkt.l2_hdr.vlan.ethertype, obj_bus.vlan_etype);
            replace_header_field(ingress_pkt.l2_hdr.l2.ethertype, obj_bus.eth_etype);
        }
    }
}

// Generate checksum of the egress packet depending on whether it
// is an EFCP or an IPv4 packet
function update_checksum() {
    if (egress_pkt.efcp_hdr.efcp._PRESENT) {
        create_checksum(egress_pkt.efcp_hdr.efcp.hdr_checksum,
            {
                egress_pkt.efcp_hdr.efcp.version, egress_pkt.efcp_hdr.efcp.ipc_dst_addr,
                egress_pkt.efcp_hdr.efcp.ipc_src_addr, egress_pkt.efcp_hdr.efcp.qos_id,
                egress_pkt.efcp_hdr.efcp.cep_dst_id, egress_pkt.efcp_hdr.efcp.pdutype,
                egress_pkt.efcp_hdr.efcp.cep_src_id, egress_pkt.efcp_hdr.efcp.flags,
                egress_pkt.efcp_hdr.efcp.length, egress_pkt.efcp_hdr.efcp.seq_num
            });
    } else if (egress_pkt.l3_hdr.ipv4._PRESENT) {
        create_checksum(egress_pkt.l3_hdr.ipv4.checksum,
            {
                egress_pkt.l3_hdr.ipv4.version, egress_pkt.l3_hdr.ipv4.ihl,
                egress_pkt.l3_hdr.ipv4.diffserv, egress_pkt.l3_hdr.ipv4.total_len,
                egress_pkt.l3_hdr.ipv4.identification, 
                egress_pkt.l3_hdr.ipv4.flags, egress_pkt.l3_hdr.ipv4.frag_offset,
                egress_pkt.l3_hdr.ipv4.ttl, egress_pkt.l3_hdr.ipv4.protocol,
                egress_pkt.l3_hdr.ipv4.src_addr, egress_pkt.l3_hdr.ipv4.dst_addr
            });
    }
}


// Egress pdu type check 
// NOTES:
    // - In current BM implementation, packet drop construct will not take effect.
    // - This NPL code uses drop_vector defined in egr_aux_bus to do packet drop.
    //   The implementation of packet drop_vector is in special function
    //  _BModel::sfc_edb in bm_tests/sf_definition/bm_sfc.cpp
function pdu_check() {
    // Check that injected packet is EFCP
    if (ingress_pkt.efcp_hdr.efcp._PRESENT) {
        if ( (obj_bus.pdutype != DATA_TRANSFER) &&
             (obj_bus.pdutype != LAYER_MANAGEMENT) &&
             (obj_bus.pdutype != ACK_ONLY) &&
             (obj_bus.pdutype != NACK_ONLY) &&
             (obj_bus.pdutype != ACK_AND_FLOW_CONTROL) &&
             (obj_bus.pdutype != NACK_AND_FLOW_CONTROL) &&
             (obj_bus.pdutype != FLOW_CONTROL_ONLY) &&
             (obj_bus.pdutype != SELECTIVE_ACK) &&
             (obj_bus.pdutype != SELECTIVE_NACK) &&
             (obj_bus.pdutype != SELECTIVE_ACK_AND_FLOW_CONTROL) &&
             (obj_bus.pdutype != SELECTIVE_NACK_AND_FLOW_CONTROL) &&
             (obj_bus.pdutype != CONTROL_ACK) &&
             (obj_bus.pdutype != RENDEVOUS) ) {

            print("Wrong PDU Type, droping packet...\n");
            local.wrong_pdu_type = 1;

            packet_drop(local.wrong_pdu_type, DROP_REASON__WRONG_PDU, 0);

            // Set drop_vector at egress based on BM implemetation
            egr_aux_bus.drop_vector = DROP_REASON__WRONG_PDU;
        }
    }
}


/*************************************
SETUP FOR NPL ENVIRONMENT
*************************************/
function memory_init() {
    ccbe.dst_port = 0;
    ccbi.l3_pbm = 0;
}


/*************************************
PROGRAM
*************************************/
program efcp_router {

    // NPL setup
    memory_init();
    // - In VI Component - implement Iarb and drive these signals
    iarb.usage_mode_create(0,
            control_id.otpid_enable,
            control_id.ts_enable,
            obj_bus.port_num,
            obj_bus.port_type_cfg,
            time_bus.currenttime
            );
    iarb.execute();

    // Ingress pipeline
    // - Start parsing the different types of packet
    parse_begin(start);
    // - Invoke port table
    port_table.lookup(0);
    
    // Table invocation
    // - If EFCP header is present, invoke its related table
    if (ingress_pkt.efcp_hdr.efcp._PRESENT) {
        efcp_forward_table.lookup(0);
    }
    // - If IPV4 header is present, invoke its related table
    if (ingress_pkt.l3_hdr.ipv4._PRESENT) {
        ipv4_forward_table.lookup(0);
    }        
    // - Check specific tables to assess where to forward the packet to (depends on the layer in use)
    resolve_destination();

    // NPL setup
    mmu.usage_mode_create(0,
            ccbi.l2_pbm,
            ccbi.l3_pbm,
            ccbe.dst_port
            );
    mmu.execute();

    // Egress pipeline
    // - Copies content of one bus into another. Optional
    assign_ing_to_egr_bus();
    // - Check if the packet needs to be dropped due to wrong pdu type
    pdu_check();
    // - Manage the existence of the VLAN header
    handle_vlan();
    do_modify_packet();
    update_checksum();    
    print_egress_packet();    
    
    // NPL setup
    // - In VI Component - Implement drop functionality in End of the Pipe 
    edb.usage_mode_create( 0,
            egr_aux_bus.drop_vector,
            egr_obj_bus.dst_modid,
            egr_obj_bus.dst_port
            );
    edb.execute();
}
