// This program implements the Error And Flow Control Protocol (EFCP), as well as legacy protocols

#include "bus.npl"
#include "parser.npl"
#include "special_function.npl"
#include "table.npl"
#include "debug.npl"

/*************************************
FUNCTION DECLARATION
*************************************/

// Resolve Destination
// - Pick destination results from one of the table lookups
function resolve_destination() {
    // By default on obj_bus dst_modid and dst_port are from the L2 table.
    // However if L3 lookup was successful then pick it from nhi table.
    ccbi.l2_pbm = 1 << obj_bus.dst_port;
}

// Assign data from the ingress bus (used in the ingress pipeline) to
// data in the egress bus (used in the egress pipeline)
// - Not needed by the logic (a single bus could be used for the whole program),
// - but nevertheless provided for architectural and educational reasons
function assign_ing_to_egr_bus() {
    egr_obj_bus.dst_modid       = obj_bus.dst_modid;
    egr_obj_bus.dst_port        = ccbe.dst_port;
    egr_obj_bus.ing_port        = obj_bus.port_num;
    egr_obj_bus.ingress_timestamp = time_bus.currenttime;
    egr_aux_bus.drop_vector     = 0;
}


/*************************************
PACKET MODIFICATION
*************************************/
// - To be implemented on Flex editor
function do_modify_packet () { //to be implemented on flex editor    
    egress_pkt.l2_hdr.l2 = ingress_pkt.l2_hdr.l2;
    egress_pkt.l2_hdr.vlan = ingress_pkt.l2_hdr.vlan;
    egress_pkt.efcp_hdr.efcp = ingress_pkt.efcp_hdr.efcp;
}

// TODO: document better
// Manage the VLAN header in the ingress packet
function handle_vlan() {            
    if (ingress_pkt.l2_hdr.vlan._PRESENT) {        
        if (obj_bus.vid == 0) {
            print("VLAN header present with vid = 0\n");
            delete_header(ingress_pkt.l2_hdr.vlan);
            obj_bus.eth_etype = EFCP;        
            replace_header_field(ingress_pkt.l2_hdr.l2.ethertype, obj_bus.eth_etype);
        } else {
            print("VLAN header present, but not 0. vid = 0X%x\n", obj_bus.vid);
            replace_header_field(ingress_pkt.l2_hdr.vlan.vid, obj_bus.vid);
        }
    } else {
        if (obj_bus.vid != 0) {
            print("Added VLAN header\n");        
            add_header(ingress_pkt.l2_hdr.vlan);
            replace_header_field(ingress_pkt.l2_hdr.vlan.vid, obj_bus.vid);
            obj_bus.eth_etype = VLAN;
            obj_bus.vlan_etype = EFCP;        
            replace_header_field(ingress_pkt.l2_hdr.vlan.ethertype, obj_bus.vlan_etype);
            replace_header_field(ingress_pkt.l2_hdr.l2.ethertype, obj_bus.eth_etype);
        }
    }
}

function update_efcp_checksum() {
    create_checksum(
        egress_pkt.efcp_hdr.efcp.hdr_checksum,
        {
            egress_pkt.efcp_hdr.efcp.version, egress_pkt.efcp_hdr.efcp.ipc_dst_addr,
            egress_pkt.efcp_hdr.efcp.ipc_src_addr, egress_pkt.efcp_hdr.efcp.qos_id,
            egress_pkt.efcp_hdr.efcp.cep_dst_id, egress_pkt.efcp_hdr.efcp.pdutype,
            egress_pkt.efcp_hdr.efcp.cep_src_id, egress_pkt.efcp_hdr.efcp.flags,
            egress_pkt.efcp_hdr.efcp.length, egress_pkt.efcp_hdr.efcp.seq_num
        });
}

function memory_init() {
    ccbe.dst_port = 0;
    ccbi.l3_pbm = 0;
}


/*************************************
PROGRAM
*************************************/
program efcp_switch {

    // NLP setup
    memory_init();
    // - In VI Component - implement Iarb and drive these signals
    iarb.usage_mode_create(0,
            control_id.otpid_enable,
            control_id.ts_enable,
            obj_bus.port_num,
            obj_bus.port_type_cfg,
            time_bus.currenttime
            );
    iarb.execute();

    // Ingress pipeline
    // - Start parsing the different types of packet
    parse_begin(start);
    // - Invoke port table
    port_table.lookup(0);
    // - Invoke EFCP table
    efcp_forward_table.lookup(0);
    // - Check specific tables to know where to forward the packet to (depends on the layer in use)
    resolve_destination();

    // NLP setup
    mmu.usage_mode_create(0,
            ccbi.l2_pbm,
            ccbi.l3_pbm,
            ccbe.dst_port
            );
    mmu.execute();

    // Egress pipeline
    // - Copies content of one bus into another. Optional
    assign_ing_to_egr_bus();
    // - Manage the existence of the VLAN header
    handle_vlan();
    // - Copy some headers of the ingress packet into the egress packet (currently, L2-related data)
    do_modify_packet();
    update_efcp_checksum();
    print_egress_packet();

    // NLP setup
    // - In VI Component - implement drop functionality in End of the Pipe
    edb.usage_mode_create(0,
            egr_aux_bus.drop_vector,
            egr_obj_bus.dst_modid,
            egr_obj_bus.dst_port
            );
    edb.execute();
}
