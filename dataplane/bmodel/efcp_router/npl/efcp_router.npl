//This Program lists Simple L2 Switch Functionality
#include "efcp_bus.npl"
#include "efcp_parser.npl"
#include "efcp_sf_defines.npl"

/********************
TABLE SPECIFICATION
********************/
/********************
PORT TABLE
********************/
logical_table port_table {

    table_type : index;
    minsize    : 128;
    maxsize    : 128;

    keys {
        bit[PORT_NUM_WIDTH] port_num;
    }

    fields {
        bit[8]  src_modid;
        bit[12] default_vid;
    }

    key_construct() {
        if (_LOOKUP0 == 1) {
            port_num = obj_bus.port_num;
        }
    }

    fields_assign() {
        if (_LOOKUP0 == 1) {
            obj_bus.src_modid = src_modid;
            obj_bus.port_vid = default_vid;
        }
    }
}

/********************
EFCP LOGICAL TABLE
********************/
logical_table efcp_forward_table {

    table_type : hash;
    /*Minimum guaranteed size. Physical table must have this
    number of entries.*/
    minsize    : 8192;

    /*Maximum allowed size. This is mainly for SDK populate
    purposes, in case maxsize and minsize have different
    values.
    If minsize and maxsize are the same, then it is treated
    as constant "size" for that table. The compiler must find
    a physical table of the specified size.*/
    maxsize    : 16384;

    keys{
        bit[16] dest_addr;     
    }

    fields {  
        bit[12]             vid;
        bit[48]             macda; 
        bit[PORT_NUM_WIDTH] dst_port; 
        bit[8]              dst_modid;
    }

    key_construct() {
        if(_LOOKUP0 == 1) {           
            dest_addr = ingress_pkt.efcp_hdr.efcp.dstAddr;
        }
    }

    fields_assign() {
        if(_LOOKUP0 == 1) {
            /* Mas tarde en la funcion do_packet_modif() se asigna egress_pkt =
            ingress_pkt, por eso se guarda la mac en ingress.*/ 
            ingress_pkt.group1.l2.macda = macda;            
            obj_bus.vid = vid;            
            obj_bus.dst_modid = dst_modid;
            obj_bus.dst_port = dst_port;
        }
    }
}

/********************
IPv4 LOGICAL TABLE
********************/
logical_table ipv4_forward_table {

    table_type : hash;

    minsize    : 8192;
    maxsize    : 16384;

    keys{
        bit[32] dest_addr;     
    }

    fields {  
        bit[12]             vid;
        bit[48]             macda; 
        bit[PORT_NUM_WIDTH] dst_port; 
        bit[8]              dst_modid;
    }

    key_construct() {
        if(_LOOKUP0 == 1) {           
            dest_addr = ingress_pkt.l3_hdr.ipv4.dstAddr;
        }
    }

    fields_assign() {
        if(_LOOKUP0 == 1) {
            /* Mas tarde en la funcion do_packet_modif() se asigna egress_pkt =
            ingress_pkt, por eso se guarda la mac en ingress.*/ 
            ingress_pkt.group1.l2.macda = macda;            
            obj_bus.vid = vid;            
            obj_bus.dst_modid = dst_modid;
            obj_bus.dst_port = dst_port;
        }
    }
}


/***********************
EGRESS TABLES
***********************/

/*************************************
FUNCTION DECLARATION
*************************************/

/*************************************
Resolve Destination 
 - Pick destination results from one of the table lookups
*************************************/
function resolve_destination() { 
    /*By default on obj_bus dst_modid and dst_port are from the L2 table.
    However if L3 lookup was successful then pick it from nhi table.*/
        ccbi.l2_pbm = 1 << obj_bus.dst_port;
}


/*************************************
ASSIGN to EGR BUS 
 - Notional Only for clarity of understanding. Need not do this.
*************************************/
function assign_ing_to_egr_bus() {
    egr_obj_bus.dst_modid       = obj_bus.dst_modid;
    egr_obj_bus.dst_port        = ccbe.dst_port;
    egr_obj_bus.ing_port        = obj_bus.port_num;
    egr_obj_bus.ingress_timestamp = time_bus.currenttime;
    egr_aux_bus.drop_vector     = 0;
}


/*************************************
PACKET MODIFICATION
*************************************/
function do_packet_modif() { //to be implemented on flex editor        
    egress_pkt.group1.l2 = ingress_pkt.group1.l2;
    egress_pkt.group1.vlan = ingress_pkt.group1.vlan;
    egress_pkt.efcp_hdr.efcp = ingress_pkt.efcp_hdr.efcp;
    egress_pkt.l3_hdr.ipv4 = ingress_pkt.l3_hdr.ipv4;
}

function handle_vlan(){            
    if(ingress_pkt.group1.vlan._PRESENT){        
        if(obj_bus.vid == 0){
            print("VLAN header present with vid = 0\n");
            delete_header(ingress_pkt.group1.vlan);

            if(ingress_pkt.efcp_hdr.efcp._PRESENT) {
                obj_bus.eth_etype = EFCP;        
            }
            else if(ingress_pkt.l3_hdr.ipv4._PRESENT) {
                obj_bus.eth_etype = IPv4;        
            } 

            replace_header_field(ingress_pkt.group1.l2.ethertype, obj_bus.eth_etype);
        }
        else {
            print("VLAN header present, but vid not 0. vid = 0X%x\n", obj_bus.vid);
            replace_header_field(ingress_pkt.group1.vlan.vid, obj_bus.vid);
        }
    }
    else {
        if(obj_bus.vid != 0){
            print("Added VLAN header\n");        
            add_header(ingress_pkt.group1.vlan);
            replace_header_field(ingress_pkt.group1.vlan.vid, obj_bus.vid);
            obj_bus.eth_etype = VLAN;

            if(ingress_pkt.efcp_hdr.efcp._PRESENT) {
                obj_bus.vlan_etype = EFCP;        
            }
            else if(ingress_pkt.l3_hdr.ipv4._PRESENT) {
                obj_bus.vlan_etype = IPv4;        
            }                        

            replace_header_field(ingress_pkt.group1.vlan.ethertype, obj_bus.vlan_etype);
            replace_header_field(ingress_pkt.group1.l2.ethertype, obj_bus.eth_etype);
        }
    }
}

function update_checksum() {
    if(egress_pkt.efcp_hdr.efcp._PRESENT){        
        create_checksum(egress_pkt.efcp_hdr.efcp.hdrChecksum,
            {
                egress_pkt.efcp_hdr.efcp.vers, egress_pkt.efcp_hdr.efcp.dstAddr,
                egress_pkt.efcp_hdr.efcp.srcAddr, egress_pkt.efcp_hdr.efcp.qosID,
                egress_pkt.efcp_hdr.efcp.dstCEPID, egress_pkt.efcp_hdr.efcp.pduType,
                egress_pkt.efcp_hdr.efcp.srcCEPID, egress_pkt.efcp_hdr.efcp.flags,
                egress_pkt.efcp_hdr.efcp.length, egress_pkt.efcp_hdr.efcp.seqnum
            });
    }
    else if(egress_pkt.l3_hdr.ipv4._PRESENT){
        create_checksum(egress_pkt.l3_hdr.ipv4.checksum,
            {
                egress_pkt.l3_hdr.ipv4.version, egress_pkt.l3_hdr.ipv4.ihl,
                egress_pkt.l3_hdr.ipv4.diffserv, egress_pkt.l3_hdr.ipv4.totalLen,
                egress_pkt.l3_hdr.ipv4.identification, 
                egress_pkt.l3_hdr.ipv4.flags, egress_pkt.l3_hdr.ipv4.fragOffset,
                egress_pkt.l3_hdr.ipv4.ttl, egress_pkt.l3_hdr.ipv4.protocol,
                egress_pkt.l3_hdr.ipv4.srcAddr, egress_pkt.l3_hdr.ipv4.dstAddr
            });
    }    
}


function memory_init() {
    ccbe.dst_port = 0;
    ccbi.l3_pbm = 0;
}

/*************************************
DEBUG
*************************************/
//Print egress packet
function print_packet() {
    print("\n### Ethernet ###\n");
    print("\nMAC destiation = 0X%x\n", egress_pkt.group1.l2.macda);
    print("MAC source = 0X%x\n", egress_pkt.group1.l2.macsa);
    print("Ethertype = 0X%x\n", egress_pkt.group1.l2.ethertype);

    if(egress_pkt.group1.vlan._PRESENT){
        print("\n\t### VLAN ###\n");
        print("\n\tPriority Code Point = X%x\n", egress_pkt.group1.vlan.pcp);
        print("\tDrop Eligible Indicator = X%x\n", egress_pkt.group1.vlan.cfi);
        print("\tVLAN id = X%x\n", egress_pkt.group1.vlan.vid);
        print("\tEthertype = X%x\n", egress_pkt.group1.vlan.ethertype);        
    }

    if(egress_pkt.efcp_hdr.efcp._PRESENT) {
        print("\n\t\t### EFCP ###\n");
        print("\n\t\tVersion = 0X%x\n", egress_pkt.efcp_hdr.efcp.vers);
        print("\t\tDestination address = 0X%x\n", egress_pkt.efcp_hdr.efcp.dstAddr);
        print("\t\tSource address = 0X%x\n", egress_pkt.efcp_hdr.efcp.srcAddr);
        print("\t\tQoS ID = 0X%x\n", egress_pkt.efcp_hdr.efcp.qosID);
        print("\t\tSource CEPID = 0X%x\n", egress_pkt.efcp_hdr.efcp.srcCEPID);
        print("\t\tPDU Type = 0X%x\n", egress_pkt.efcp_hdr.efcp.pduType);
        print("\t\tFlags = 0X%x\n", egress_pkt.efcp_hdr.efcp.flags);
        print("\t\tLength = 0X%x\n", egress_pkt.efcp_hdr.efcp.length);
        print("\t\tSequence number = 0X%x\n", egress_pkt.efcp_hdr.efcp.seqnum);
        print("\t\tChecksum = 0X%x\n\n", egress_pkt.efcp_hdr.efcp.hdrChecksum);
    }

    if(egress_pkt.l3_hdr.ipv4._PRESENT) {
        print("\n\t\t### IP ###\n");
        print("\n\t\tVersion = 0X%x\n", egress_pkt.l3_hdr.ipv4.version);        
        print("\t\tIHL = 0X%x\n", egress_pkt.l3_hdr.ipv4.ihl);                
        print("\t\tdiffserv = 0X%x\n", egress_pkt.l3_hdr.ipv4.diffserv);                
        print("\t\tIdentification = 0X%x\n", egress_pkt.l3_hdr.ipv4.identification);                
        print("\t\tFragmentation Offset = 0X%x\n", egress_pkt.l3_hdr.ipv4.fragOffset);                
        print("\t\tTTL = 0X%x\n", egress_pkt.l3_hdr.ipv4.ttl);                
        print("\t\tProtocol = 0X%x\n", egress_pkt.l3_hdr.ipv4.protocol);                
        print("\t\tChecksum = 0X%x\n", egress_pkt.l3_hdr.ipv4.checksum);        
        print("\t\tSource Address = 0X%x\n", egress_pkt.l3_hdr.ipv4.srcAddr);                
        print("\t\tDestination Address = 0X%x\n\n", egress_pkt.l3_hdr.ipv4.dstAddr);                
    }
}

/*************************************
PROGRAM
*************************************/
program efcp_switch {

    memory_init();

    //In VI Component - Implement Iarb and drive these signals
    iarb.usage_mode_create( 0,
            control_id.otpid_enable,
            control_id.ts_enable,
            obj_bus.port_num,
            obj_bus.port_type_cfg,
            time_bus.currenttime
            );
    iarb.execute();

    //-----Ingress---------//
    parse_begin(start);
    port_table.lookup(0);
    
    if(ingress_pkt.efcp_hdr.efcp._PRESENT){
        efcp_forward_table.lookup(0);    
    }    
    if(ingress_pkt.l3_hdr.ipv4._PRESENT){
        ipv4_forward_table.lookup(0);         
    }        

    resolve_destination();

    mmu.usage_mode_create( 0,
            ccbi.l2_pbm,
            ccbi.l3_pbm,
            ccbe.dst_port
            );
    mmu.execute();

    //-----Egress---------//
    assign_ing_to_egr_bus();

    handle_vlan();
    do_packet_modif();      
    update_checksum();    
    print_packet();    
    

    //In VI Component - Implement drop functionality in End of the Pipe 
    edb.usage_mode_create( 0,
            egr_aux_bus.drop_vector,
            egr_obj_bus.dst_modid,
            egr_obj_bus.dst_port
            );
    edb.execute();
}