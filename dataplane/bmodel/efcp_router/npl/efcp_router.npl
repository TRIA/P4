//This Program lists Simple L2 Switch Functionality
#include "efcp_bus.npl"
#include "efcp_parser.npl"
#include "efcp_sf_defines.npl"

/********************
TABLE SPECIFICATION
********************/
/********************
PORT TABLE
********************/
logical_table port_table {

    table_type : index;
    minsize    : 128;
    maxsize    : 128;

    keys {
        bit[PORT_NUM_WIDTH] port_num;
    }

    fields {
        bit[8]  src_modid;
        bit[12] default_vid;
    }

    key_construct() {
        if (_LOOKUP0 == 1) {
            port_num = obj_bus.port_num;
        }
    }

    fields_assign() {
        if (_LOOKUP0 == 1) {
            obj_bus.src_modid = src_modid;
            obj_bus.port_vid = default_vid;
        }
    }
}

/********************
EFCP LOGICAL TABLE
********************/
logical_table efcp_forward_table {

    table_type : hash;
    /*Minimum guaranteed size. Physical table must have this
    number of entries.*/
    minsize    : 8192;

    /*Maximum allowed size. This is mainly for SDK populate
    purposes, in case maxsize and minsize have different
    values.
    If minsize and maxsize are the same, then it is treated
    as constant "size" for that table. The compiler must find
    a physical table of the specified size.*/
    maxsize    : 16384;

    keys{
        bit[16] dest_addr;     
    }

    fields {          
        bit[48]             macda;        
        bit[PORT_NUM_WIDTH] dst_port; 
        bit[8]              dst_modid;
    }

    key_construct() {
        if(_LOOKUP0 == 1) {           
            dest_addr = ingress_pkt.efcp_hdr.efcp.dstAddr;
        }
    }

    fields_assign() {
        if(_LOOKUP0 == 1) {
            /* Mas tarde en la funcion do_packet_modif() se asigna egress_pkt =
            ingress_pkt, por eso se guarda la mac en ingress.*/ 
            ingress_pkt.group1.l2.macda = macda;
            obj_bus.dst_modid = dst_modid;
            obj_bus.dst_port = dst_port;
        }
    }
}


/***********************
EGRESS TABLES
***********************/

/*************************************
FUNCTION DECLARATION
*************************************/

/*************************************
Resolve Destination 
 - Pick destination results from one of the table lookups
*************************************/
function resolve_destination() { 

    /*By default on obj_bus dst_modid and dst_port are from the L2 table.
    However if L3 lookup was successful then pick it from nhi table.*/
        ccbi.l2_pbm = 1 << obj_bus.dst_port;
}


/*************************************
ASSIGN to EGR BUS 
 - Notional Only for clarity of understanding. Need not do this.
*************************************/
function assign_ing_to_egr_bus() {
    egr_obj_bus.dst_modid       = obj_bus.dst_modid;
    egr_obj_bus.dst_port        = ccbe.dst_port;
    egr_obj_bus.ing_port        = obj_bus.port_num;
    egr_obj_bus.ingress_timestamp = time_bus.currenttime;
    egr_aux_bus.drop_vector     = 0;
}


/*************************************
PACKET MODIFICATION
*************************************/
function do_packet_modif() { //to be implemented on flex editor
    egress_pkt.group1.l2 = ingress_pkt.group1.l2;
    egress_pkt.efcp_hdr.efcp = ingress_pkt.efcp_hdr.efcp;
}

function handle_vlan(){
    print("obj_bus.vid is 0X%x\n", obj_bus.vid);
    
    if(egress_pkt.group1.vlan._PRESENT){
        //Mira a ver si asigna correctamente el vid en el paquete
        /*if(egress_pkt.group1.vlan.vid == 33){
        print("vid == 33!!\n");
        }*/
        if(ingress_pkt.group1.vlan.vid == 0){
            print("He entrado en el if de vlan = 0 habiendo vlan header\n");
            delete_header(egress_pkt.group1.vlan);
        } else {                                    
            replace_header_field(egress_pkt.group1.vlan.vid, obj_bus.vid);
        }
    } else {
        if(ingress_pkt.group1.vlan.vid == 0){
            delete_header(egress_pkt.group1.vlan);
        } else {
            print("Supuestamente, added header\n");
            add_header(egress_pkt.group1.vlan);
        }
    }
}

function update_efcp_checksum() {
    create_checksum(egress_pkt.efcp_hdr.efcp.hdrChecksum,
        {
            egress_pkt.efcp_hdr.efcp.vers, egress_pkt.efcp_hdr.efcp.dstAddr,
            egress_pkt.efcp_hdr.efcp.srcAddr, egress_pkt.efcp_hdr.efcp.qosID,
            egress_pkt.efcp_hdr.efcp.dstCEPID, egress_pkt.efcp_hdr.efcp.pduType,
            egress_pkt.efcp_hdr.efcp.srcCEPID, egress_pkt.efcp_hdr.efcp.flags,
            egress_pkt.efcp_hdr.efcp.length, egress_pkt.efcp_hdr.efcp.seqnum
        });
}

function memory_init() {
    ccbe.dst_port = 0;
    ccbi.l3_pbm = 0;
}

/*************************************
DEBUG
*************************************/
//Print egress EFCP layer
function print_efcp_packet() {
    print("\n### EFCP ###\n");
    print("\nVersion = 0X%x\n", egress_pkt.efcp_hdr.efcp.vers);
    print("Destination address = 0X%x\n", egress_pkt.efcp_hdr.efcp.dstAddr);
    print("Source address = 0X%x\n", egress_pkt.efcp_hdr.efcp.srcAddr);
    print("QoS ID = 0X%x\n", egress_pkt.efcp_hdr.efcp.qosID);
    print("Source CEPID = 0X%x\n", egress_pkt.efcp_hdr.efcp.srcCEPID);
    print("PDU Type = 0X%x\n", egress_pkt.efcp_hdr.efcp.pduType);
    print("Flags = 0X%x\n", egress_pkt.efcp_hdr.efcp.flags);
    print("Length = 0X%x\n", egress_pkt.efcp_hdr.efcp.length);
    print("Sequence number = 0X%x\n", egress_pkt.efcp_hdr.efcp.seqnum);
    print("Checksum = 0X%x\n\n", egress_pkt.efcp_hdr.efcp.hdrChecksum);
}

/*************************************
PROGRAM
*************************************/
program efcp_switch {

    memory_init();

    //In VI Component - Implement Iarb and drive these signals
    iarb.usage_mode_create( 0,
            control_id.otpid_enable,
            control_id.ts_enable,
            obj_bus.port_num,
            obj_bus.port_type_cfg,
            time_bus.currenttime
            );
    iarb.execute();

    //-----Ingress---------//
    parse_begin(start);
    port_table.lookup(0);
    
    efcp_forward_table.lookup(0);    
    resolve_destination();

    mmu.usage_mode_create( 0,
            ccbi.l2_pbm,
            ccbi.l3_pbm,
            ccbe.dst_port
            );
    mmu.execute();

    //-----Egress---------//
    assign_ing_to_egr_bus();

    do_packet_modif();  
    update_efcp_checksum();    
    print_efcp_packet();    

    //In VI Component - Implement drop functionality in End of the Pipe 
    edb.usage_mode_create( 0,
            egr_aux_bus.drop_vector,
            egr_obj_bus.dst_modid,
            egr_obj_bus.dst_port
            );
    edb.execute();
}